---
layout: post
title: Î∞±Ï§Ä 19238:Ïä§ÌÉÄÌä∏ ÌÉùÏãú
date: 2021-01-10 15:05:00
author: 'SeWonKim'
categories: [algorithm]
tags: [jekyll, algorithm, Baekjoon]
fullview: false
comments: true
description: Baekjoon 19238
---

> [Baekjoon 19238](https://www.acmicpc.net/problem/19238)

## Idea

### ü•öÎ≥ÄÏàò

- int N : mapÏùò ÌÅ¨Í∏∞
- int M : ÏäπÍ∞ù Ïàò
- int count : ÏßÄÍ∏àÍπåÏßÄ ÌÉúÏö¥ ÏäπÍ∞ùÏùò Ïàò
- int fuel : Ï¥àÍ∏∞ Ïó∞Î£åÏùò Ïñë
- int[N][N] map 
- int[4][2] dir : 4Î∞©Ìñ• ÌÉêÏÉâÏùÑ ÏúÑÌïú delta
- int[N][N] dis : ÏµúÎã® Í±∞Î¶¨ ÌÉêÏÉâÏùÑ ÏúÑÌïú 2Ï∞®Ïõê Î∞∞Ïó¥
- class Customer : int distance, startR, startC, endR, endC
  
### üç≥ÌíÄÏù¥ Ï†ÑÎûµ

1. ÌÉùÏãúÏóêÏÑú ÏµúÎã® Í±∞Î¶¨Í∞Ä Í∞ÄÏû• ÏßßÏùÄ ÏäπÍ∞ùÏùÑ Í≥†Î¶Ñ
   - priorty queue Î•º ÏÇ¨Ïö©Ìï¥ÏÑú ÌÉùÏãúÏóêÏÑú Ï∂úÎ∞úÏßÄÍπåÏßÄÏùò Í±∞Î¶¨, Ìñâ, Ïó¥ ÏàúÏÑúÎ°ú Ï†ïÎ†¨ 
   - ÌòÑÏû¨ ÏúÑÏπòÏóêÏÑú ÏäπÍ∞ùÏóêÍ≤å Í∞à Ïàò ÏóÜÏúºÎ©¥ -1 Ï∂úÎ†•. Í≤åÏûÑ Ï¢ÖÎ£å.
   - Ïù¥Îèô Í∞ÄÎä•ÌïòÎ©¥ fuelÏóêÏÑú Í±∞Î¶¨Î•º ÎπºÍ≥† 2Î≤àÏúºÎ°ú ÎÑòÏñ¥Í∞ê
2. Í∑∏ ÏäπÍ∞ùÏùò ÏúÑÏπòÎ°úÎ∂ÄÌÑ∞ Î™©Ï†ÅÏßÄÍπåÏßÄÏùò ÏµúÎã® Í±∞Î¶¨Î•º Í≥ÑÏÇ∞
   - Ïó∞Î£åÍ∞Ä Î∂ÄÏ°±ÌïòÎ©¥ -1 Ï∂úÎ†•. Í≤åÏûÑ Ï¢ÖÎ£å.
   - Ïù¥Îèô Í∞ÄÎä•ÌïòÎ©¥ Ïù¥Îèô ÌõÑ ÏÜåÎ™®Ìïú Ïó∞Î£åÏùò 2Î∞∞ ÏñëÏúºÎ°ú Ï∂©Ï†Ñ ÌõÑ ÌÉùÏãúÏùò ÏúÑÏπò Î≥ÄÍ≤Ω
3. ÌÉúÏö¥ ÏäπÍ∞ù count, 1Î≤àÎ∂ÄÌÑ∞ Î∞òÎ≥µ

üî• ÌïµÏã¨ : **ÏµúÎã® Í±∞Î¶¨ Ïù¥Îèô** üî• => BFS 

&nbsp;  
&nbsp;


<details>
<summary>code - ÏãúÍ∞ÑÏ¥àÍ≥º</summary>
<div markdown="1">

```java
import java.io.*;
import java.util.*;

public class BOJ19238_Ïä§ÌÉÄÌä∏ÌÉùÏãú {
    public static class Customer implements Comparable<Customer> {
        int distance, startR, startC, endR, endC;

        public Customer(int distance, int startR, int startC, int endR, int endC) {
            this.distance = distance;
            this.startR = startR;
            this.startC = startC;
            this.endR = endR;
            this.endC = endC;
        }

        @Override
        public int compareTo(Customer o) {
            if(this.distance == o.distance) {
                if(this.startR == o.startR) return this.startC - o.startC;
                return this.startR - o.startR;
            }
            return this.distance - o.distance;
        }
    }

    static int N;
    static int[][] map;
    static int[][] dir = { {-1, 0}, {1, 0}, {0, -1}, {0, 1} };
    public static void main(String[] args) throws Exception{
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine(), " ");
        N = Integer.parseInt(st.nextToken());
        int M = Integer.parseInt(st.nextToken());
        int fuel = Integer.parseInt(st.nextToken());

        // intput
        map = new int[N][N];
        for (int i = 0; i < N; i++) {
            st = new StringTokenizer(br.readLine(), " ");
            for (int j = 0; j < N; j++) {
                map[i][j] = Integer.parseInt(st.nextToken());
            }
        }

        st = new StringTokenizer(br.readLine(), " ");
        int taxiR = Integer.parseInt(st.nextToken()) - 1;
        int taxiC = Integer.parseInt(st.nextToken()) - 1;

        PriorityQueue<Customer> customers = new PriorityQueue<Customer>();
        for (int i = 0; i < M; i++) {
            st = new StringTokenizer(br.readLine(), " ");
            int startR = Integer.parseInt(st.nextToken()) - 1;
            int startC = Integer.parseInt(st.nextToken()) - 1;
            int endR = Integer.parseInt(st.nextToken()) - 1;
            int endC = Integer.parseInt(st.nextToken()) - 1;

            customers.add(new Customer(getDistance(taxiR, taxiC, startR, startC), startR, startC, endR, endC));
        }

        while(!customers.isEmpty()) {
            // ÌÉùÏãúÏóêÏÑú Í∞ÄÏû• Í∞ÄÍπåÏö¥ ÏäπÍ∞ù ÏÑ†ÌÉù
            Customer customer = customers.poll();

            int distance = getDistance(customer.startR, customer.startC, customer.endR, customer.endC);

            if(fuel < customer.distance || fuel-customer.distance < distance) {
                System.out.println(-1);
                return;
            }

            fuel = fuel - customer.distance + distance;
            taxiR = customer.endR;
            taxiC = customer.endC;

            PriorityQueue<Customer> tmp = new PriorityQueue<>();
            while(!customers.isEmpty()) {
                Customer c = customers.poll();
                tmp.add(new Customer(getDistance(taxiR, taxiC, c.startR, c.startC), c.startR, c.startC, c.endR, c.endC));
            }
            customers = tmp;
        }
        System.out.println(fuel);
    }

    private static int getDistance(int startR, int startC, int endR, int endC) {
        int[][] distance = new int[N][N];
        for (int i = 0; i < N; i++) {
            Arrays.fill(distance[i], Integer.MAX_VALUE);
        }
        distance[startR][startC] = 0;
        Queue<int[]> q = new LinkedList<int[]>();
        q.add(new int[] {startR, startC});

        while(!q.isEmpty()) {
            int[] now = q.poll();

            for (int k = 0; k < 4; k++) {
                int nextR = now[0] + dir[k][0];
                int nextC = now[1] + dir[k][1];

                if(nextR >= 0 && nextR < N && nextC >= 0 &&nextC < N && map[nextR][nextC] != 1) {
                    if(distance[nextR][nextC] > distance[now[0]][now[1]]+1) {
                        distance[nextR][nextC] = distance[now[0]][now[1]]+1;
                        q.add(new int[] {nextR, nextC});
                    }
                }
            }
        }
        return distance[endR][endC];
    }
}

```

</div>
</details>

&nbsp;  
&nbsp;

## Review


&nbsp;  
&nbsp;
