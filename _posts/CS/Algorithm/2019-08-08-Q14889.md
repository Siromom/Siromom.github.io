---
layout: post
title: 백준 14889:스타트와 링크
date: 2019-08-08 10:19:00
author: "SeWonKim"
categories: [CS, Algorithm]
tags: [알고리즘, BOJ]
comments: true
---

> [Baekjoon 14889](https://www.acmicpc.net/problem/14889)         

# 키워드

브루트포스, 조합


# 아이디어
  1. n개 중 n/2개 뽑기 `조합` 
  2. 최악의 경우 C(20,10) = 약 18만 개 👉 경우의 수가 크지 않기 때문에 다 해본다 `브루트포스`
  3. 팀을 나누는 경우의 수마다 팀 능력치 차이 계산
  4. 최솟값 출력


### 다른 풀이
  순열을 이용하지 않는다면 재귀함수를 이용해서 백트래킹으로 풀이 가능하다.

------



## Code
```cpp
#include<iostream>
#include<vector>
#include<algorithm>
#include<stdlib.h>
using namespace std;

int main() {

	int n;
	cin >> n;

	int s[21][21];
	for (int i = 0; i < n; i++) {
		for (int j = 0; j < n; j++) {
			cin >> s[i][j];
		}
	}

	vector<int> team(n);
	for (int i = 0; i < n/2; i++) {
		team[i] = 1;
	}
	sort(team.begin(), team.end());

	int ans = 1000000000;
	do {
		vector<int> first, second;
		for (int i = 0; i < n; i++) {
			if (team[i] == 0) {
				first.push_back(i);
			}
			else {
				second.push_back(i);
			}
		}

		int start = 0;
		int link = 0;
		for (int i = 0; i < n / 2; i++) {
			for (int j = 0; j < n / 2; j++) {
				if (i == j) continue;

				start += s[first[i]][first[j]];
				link += s[second[i]][second[j]];
			}
		}
		
		int diff = abs(start-link);
		if (ans > diff) {
			ans = diff;
		}

	} while (next_permutation(team.begin(), team.end()));
	
	cout << ans << "\n";

	return 0;
}
``` 



## Review
  모든 팀을 나누기 위해서 for문 돌리는 것만 생각했지 순열을 사용하는 것은 생각하지 못했다.     
  순열은 숫자가 중복되지 않을 때에만 순서를 정하기 위해서 사용하는 것이라고 생각했기 때문인 것 같다.     
  next_permutation은 중복이 있는 원소들의 경우 중복인 경우를 제외하고 순열을 만들어준다.
  
  최솟값을 구할 때 비교 초깃값을 큰 값을 넣어준다.     
  int최댓값은 2147483647라서 이걸 넣어줘도 되는데 실수로 오버플로우되기 쉽기 때문에 보통 10억을 많이 넣는다.
