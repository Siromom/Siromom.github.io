---
layout: post
title: CPU와 프로세스
date: 2019-09-13 16:34:00
author: "SeWonKim"
categories: [CS, OS]
tags: [OS]
fullview: false
comments: true
description: CPU와 프로세스
---

# OS의 기능

## key point

1. OS가 프로그램을 실행하는 구조  
   : 컴퓨터에 설치된 프로그램(애플리케이션)은 보통 하드디스크 안에 있지만 OS가 프로그램을 실행할 때에는 이것을 메모리상으로 로드한 후 실행한다.
   이 메모리상에 할당된 프로그램을 '프로세스'라고 한다. 프로세스가 CPU에 할당되어 처리 중일 때 '실행 상태'라고한다.  
   OS는 RASIS로 성능과 안정성이 달성되어있는지 평가할 수 있다. (Reliability, Availability, Serviceability, Integrity, Security)
2. 멀티태스킹  
   : OS가 CPU에게 의뢰하는 작업 단위를 태스크(Task)라고한다. (프로세스와 동일 의미로 생각해도 무방)
   OS가 여러개의 태스크를 동시에 처리하는 능력을 멀티태스킹이라고 한다. 실제로는 동시에 처리하지 않고 OS가 CPU에게 태스크를 순서대로 할당하는 스케줄링을 통해서 처리되는데
   이 전환이 아주 빠른 속도로 수행되기 때문에 동시에 처리하는 것처럼 보이는 것뿐이다.
   프로세스가 메모리와 같은 공유 자원을 이용할 때에는 여러 개의 프로세스가 같은 시기에 변경되지 않도록 자원을 Lock 하는 일도 발생하는데,
   타이밍이 나쁘면 잠금이 해제될 때까지 서로 계속 기다리게 되는 데드락이 발생한다.

---

## 🖥️잡과 태스크

### Job

인간이 컴퓨터에게 시키는 일의 단위. 잡 안에 여러 프로그램의 실행이 포함된다.  
OS는 잡을 실행순으로 나누고 순서대로 처리하는데 잡을 작게 나눈 처리 단위를 잡 스텝(Job step)이라고 한다.
잡 실행 방법을 지정하는 언어를 '잡 제어 언어(JCL)'라고 한다.

### Task

태스크는 OS입장에서 본 작업의 단위. 프로세스나 스레드를 태스크라고 부르기도 한다.  
OS는 잡 스탭을 태스크로 분해하여 CPU에게 처리를 의뢰한다.

## 🖥️스루풋(Throughput)

OS의 단위 시간당 처리 능력.  
스루풋이 높으면 처리 효율이 좋은 것이다.

### Response Time & Turnaround Time

OS가 잡을 처리하는 시간 분류  
![image](https://user-images.githubusercontent.com/30452963/64860592-94a07f80-d668-11e9-874a-9a6bc7acf69e.png)

- Response Time : CPU의 처리 시간
- Turnaround Time : 처리 조건 입력 시간 + CPU의 처리 시간 + 처리 결과 출력 시간

### 스풀(Spool)

CPU로부터 I/O 장치로 가는 명령을 메모리와 같이 비교적 고속인 기억 장치에 일시적으로 저장하는 것을 스풀이라고 한다.  
프린터는 CPU에 비해서 처리 속도가 느리기 때문에 스풀을 사용해서 CPU처리와 입출력 동작 처리의 차이를 완화시킬 수 있다.  
메모리 디스크에 저장된 스풀 데이터를 '스풀 파일'이라고 한다.

## 🖥️인터럽트(Interrupt)

인터럽트는 실행 중인 프로그램을 중단하고 우선순위가 높은 다른 프로그램에게 CPU를 할당하여 실행하는 것이다.  
인터럽트에는 내부 인터럽트(소프트웨어 인터럽트)와 외부 인터럽트(하드웨어 인터럽트)가 있다.

### 내부 인터럽트

내부 인터럽트는 실행 중인 프로그램이 원인이 되어 일어나는 인터럽트다.

- 프로그램 인터럽트  
  Overflow로 쓰기가 허가되지 않은 메모리 영역에 액세스 했을 때, 프로그램 인터럽트가 발생해 OS에게 overflow사실을 알린다.  
  그 밖에도 무효한 메모리를 참조하는 Page fault, 디버그를 위해 프로그램을 한 명령씩 실행하는 Trace, Superviser call 실행할 때, 무효한 명령을 실행할 때 프로그램 인터럽트가 발생한다.

### 외부 인터럽트

외부 인터럽트는 주변기기의 입출력 동작이나, 하드웨어 고장, 오작동으로 인해 발생하는 인터럽트다.

- 기계 체크 인터럽트  
  하드웨어에 장애가 발생한 것을 OS에게 알린다.
- 타이머 인터럽트  
  일정시간 또는 일정시간마다 하드웨어로부터 발생하는 인터럽트
- 입출력 인터럽트  
  주변 기기의 입출력 동작이 상태가 바뀌었을 때 발생하는 인터럽트
- 콘솔 인터럽트  
  사용자가 I/O장치를 조작하면 인터럽트가 발생한다.

## 🖥️프로세스(Process)

사용자가 프로그램을 실행하면 OS는 그 내용을 메모리에 로드해서 처리를 실행한다. 이 때 메모리에 할당된 프로그램을 프로세스라고 한다.  
하나의 프로그램으로부터 여러 개의 프로세스를 만드는 게 가능한다.

### 멀티태스킹

OS관리 하에서 여러 개의 프로세스가 병행하여 작동하는 것을 말한다.  
태스크 전환에는 약간의 시간(오버헤드)가 걸린다.

### 시분할 처리 시스템(Time Sharing System)

여러 사용자가 한 대의 고성능 컴퓨터를 공유하여 사용할 때 CPU의 사용 권한을 사용자에게 순서대로 단시간 할당하는 시스템을 말한다(TSS).
사용자에게는 마치 자신이 컴퓨터를 점유하고 있는 것처럼 보인다.

## 🖥️프로세스 관리

### 프로세스의 3가지 상태

1. 대기 상태 : 입출력 동작을 기다리는 상태
2. 실행 가능 상태 : CPU의 사용권한 할당을 기다리는 상태
3. 실행 상태 : 프로세스에 CPU 사용권한이 할당되어 실행되고 있는 상태

### 디스패치와 프리엠션

실행가능 상태 -> 실행상태 = 디스패치(Dispatch)
실행상태 -> 실행가능 상태 = 프리엠션(Preemption)

가장 우선순위가 높은 실행 가능 상태의 프로세스에 디스패치가 일어나고, 작업이 끝나면 프리엠션되어 다음 프로세스를 실행한다.

## 🖥️멀티태스킹의 종류

1. 프리엠티브(Preemptive Multitasking)  
   : OS가 실행 가능 상태인 태스크에게 CPU의 사용권을 할당하고 강제적으로 태스크를 전환하여 관리하는 것
2. 논프리엠티브(Non-Preemptive Multitasking)  
   : 실행 중인 태스크가 처리를 수행하지 않는 시간을 자발적으로 해제함으로써 다른 태스크와 동시에 실행할 수 있도록 하는 것  
   태스크가 종료될 때까지 CPU의 사용 권한을 다른 태스크에게 양보하지 않는다. CPU를 해제하지 않는 태스크가 있으면 OS 전체 동작이 정지되는 경우도 있다.

## 🖥️스케줄링

OS가 여러개의 프로세스를 처리할 때 CPU를 할당할 순서를 정하는 것을 스케줄링이라고 한다. 스케줄링하기 위한 소프트웨어를 스케줄러라고 한다.  
스케줄링은 스루풋이 향상되고 응답시간이 단축되도록 한다.

### 스케줄링의 종류

- 라운드 로빈 방식(Round Robin Scheduling)  
  : 프로세스가 기다리고 있는 순서대로 일정시간씩 CPU를 할당해서 시간이 초과한 프로세스를 맨 마지막으로 보내는 방식
- 우선순위 방식  
  : OS가 프로세스의 우선순위를 정해서 우선순위가 높은 프로세스부터 실행해 나가는 방식

## 🖥️프로세스 제어

### 프로그램 상태어(PSW: Program Status Word)

인터럽트로 인해 중단된 프로그램의 상태, 연산의 종료 상태를 저장해 두는 레지스터.

![image](https://user-images.githubusercontent.com/30452963/64863361-a174a180-d66f-11e9-9194-5ee0caba204f.png)
언어가 아니라 저장영역이다.

### 프로세스 제어 블럭(PCB: Process Control Block)

각 프로세스의 CPU 상태(컨텍스트)나 프로세스의 상태를 저장해두는 메모리 영역을 PCB라고 한다.

### 컨텍스트 스위치

인터럽트로 인해 프로세스를 전환할 때 OS가 컨텍스트를 PCB에 저장하고 복원하는 것을 컨텍스트 스위치라고 한다.

- CPU에 할당한 프로세스를 다른 프로세스로 전환할 때
- 원래 프로세스로 돌아올 때

## 🖥️프로세스의 분기

프로세스의 일을 분담하여 작업 효율을 높인다.

### fork

시스템 콜에 의해 프로세스를 복사하는 것.  
원본을 부모 프로세스, 복사된 쪽을 자식 프로세스라고 한다.  
fork하면 자식 프로세스용으로 새로운 PCB와 메모리 공간이 마련된다.

### exec

자식 프로세스에서 다른 프로그램을 실행하도록 지시하는 것.

### wait

자식 프로세스의 처리가 끝나면 부모 프로세스에게 시그널이 보내진다. 이것을 기다림으로써 부모는 자식 프로세스의 종료까지 대기할 수 있다.
그 후 wait 시스템 콜에 의해 자식 프로세스에게 마련된 PCB와 메모리가 제거된다.
부모 프로세스는 하나의 wait 처리가 완료 될 때까지 다른 자식 프로세스의 종료 시그널을 받을 수 없다.

## 🖥️프로세스의 동기

여러 개의 프로세스가 파일이나 데이터베이스에 동시에 액세스하여 다룰 때에는 주의가 필요하다.

### 배타 제어

처리가 끝날때까지 프로세스에게 자원을 독점 시키는 것을 말한다.  
예를 들어 프로세스 A, B, C가 10이라는 데이터에 대해 계산을 수행한다고 가정해보면

```
프로세스 A = 1을 더한다
프로세스 B = 2를 뺀다
프로세스 C = 3을 더한다

**배타 제어가 있는 경우**
10 -> A -> 11 -> B -> 9 -> C -> 12
처리결과 12가 된다.

**배타 제어가 없는 경우**
10 -> A -> 11
10 -> B -> 8
10 -> C -> 13
처리결과 13이 된다.
```

배타 제어를 하면 누군가 조작 중인 데이터에 대해 참조나 변경을 할 수 없다.

### 세마포

공유 자원에 액세스하는 수를 정해놓는 장치를 세마포라고 한다.
정해진 수 이상 프로세스가 동시 액세스하지 않도록 카운터를 사용한다.

OS는 세마포의 P조작(획득)과 V조작(해제)으로 '통행가능, 통행불가능' 같은 두가지 상태를 관리한다.  
세마포의 카운터가 초기값을 2로 한 경우에 프로세스 A가 액세스하면 P조작으로 카운터가 1 감소되고,
프로세스 B가 액세스하면 P조작으로 카운터가 1 감소해 통행 불가 상태가 된다.
카운터가 0이 될 경우 프로세스 C가 액세스 하지 못한다.
프로세스가 V조작을 하면 카운터가 1 증가하게 된다.

## 🖥️데드락(dead lock)

배타 제어에서는 데드락에 주의해야한다.  
2개의 프로세스가 공유 자원을 잠근 채로 서로의 공유 자원에 액세스 하려고 하면 양쪽 프로세스 모두 영구적으로 대기상태가 되는데 이것을 데드락이라고 한다.

베타 제어를 하면 조작 중인 데이터에 대해 참조나 공유를 할 수 없지만 공유 잠금을 하면 변경은 불가하나 참조는 가능하다.

### 뮤텍스(Mutex)

데드락을 피하기 위한 방법으로는 세마포와 뮤텍스가 있다.
뮤텍스는 세마포의 카운터 초기값이 1인 경우를 말한다.

## 🖥️프로세스 간 통신

프로세스끼리는 다른 메모리 공간을 참조한다. 따라서 서로 어떤 데이터를 가지고 있는지 알 수 없다.  
OS에는 프로세스끼리 통신을 통해 데이터를 주고받을 수 있다.

- 메시지 큐  
  : 프로세스끼리는 메시지 기능을 사용해 1:1로 통신이 가능하다. 메시지를 넣는 장소를 메시지 큐라고 한다.
- 파이프  
  : 여러 개의 프로세스 입출력을 연결하는 장치. fork한 부모 자식 프로세스 간 이용.
- 이름 붙은 파이프  
  : 파이프에 이름을 붙여 부모 자식 관계의 프로세스가 아니어도 이용할 수 잇도록 한 파이프

## 🖥️공유 메모리와 스레드

### 공유 메모리

여러 개의 프로세스에서 공통으로 사용할 수 있는 메모리 영역. 시스템 콜에 의해 작성된다.  
공유 메모리에 접속하는 것을 Attach, 접속을 끊는 것을 Detach라고 한다.

### 스레드

프로세스 안의 프로그램 실행의 흐름.

스레드는 분기가 가능해서 여러 개의 스레드를 동시에 실행할 수 있다. 이것을 멀티 스레드라고 한다.

### 프로세스와 스레드의 차이

- 여러 프로세스를 실행하는 경우 : 각 프로세스는 다른 메모리를 참조한다.
- 멀티스레드의 경우 : 각 스레드는 같은 메모리를 참조한다. 메모리 이용 효율을 높일 수 있다.

### 멀티 프로세서(Multi-Processor)

1대의 컴퓨터가 여러 개의 CPU를 갖고 있는 것을 멀티 프로세서라고 한다.  
멀티 프로세서는 처리를 병렬로 실행하여 결과를 고속으로 출력한다. 장애가 발생했을 때 정상인 CPU만으로 처리를 계속할 수 잇다는 장점이 있다.

_멀티 프로세서 종류_

- Tighty Coupled Multi-Processor
- Loosely Coupled Multi-Processor

_멀티 프로세서 설계_

- SIMD(Single Instruction Multiple Data)
- MISD(Multiple Instruction Single Data)
- MIMD(Multiple Instruction Multiple Data)

---

## 용어정리

1. 프로세스(Process)
2. 인터럽트(Interrupt)
3. 멀티태스킹(Multi-Tasking)
4. 스케줄링(Scheduling)
5. 데드락(Dead Lock)
