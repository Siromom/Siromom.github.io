---
sidebar_position: 2
tags: ['독후감']
last_update:
  date: 8/23/2022
  author: sewonkimm
---

# Clean Code

## 14장  - 점진적인 개선
> 2022.5.20

- 14~16장은 코드와 리팩토링 과정을 상세히 기술해두어서 쭉 연결해서 읽는 게 좋은 것 같다.
- 예시들을 보면서 이런 책을 쓰는 개발자도 간단한 프로그램을 작성할 때, 이렇게 개선해나고 한 번에 완벽한 코드를 작성하지 않는다는 사실을 알게 되어서 흥미로웠다.
- 책 내용에서 휴리스틱을 언급하는데 '이 부분은 ~한 이유로 ~하게 리팩토링 해야한다'고 누구한테 배운적이 없어서 나에게 필요한 지식이라고 느껴졌다. 다음에는 'Refactoring'이라는 책을 읽어보는 것이 좋겠다.
  
### 명령행 인수의 구문을 분석하는 유틸리티 Args를 구현

*명령행 인수; 외부에서 특정값을 main 함수로 전달받을 목적으로 사용되는 인수*

- 깨끗한 코드를 짜려면 먼저 지저분한 코드를 짠 뒤에 정리해야한다.
- '돌아가는' 프로그램을 그대로 내버려두는 것은 프로그래머로서 자살행위이다. 돌아가는 코드로는 부족하다. 유지보수 비용과 시간을 아끼려면 코드를 깔끔하고 단순하게 정리하자.
- 프로그램을 망치는 가장 좋은 방법은 개선이라는 이름 아래 구조를 크게 뒤집는 행위다. '개선'전과 똑같이 프로그램을 돌리기가 아주 어렵기 때문이다. 
- 최근에도 회사 프로젝트를 개선이라는 이름 아래 구조를 크게 뒤집었는데 반성한다.

- TDD는 언제 어느 때라도 시스템이 돌아가야 한다는 원칙을 따른다.
- 인수 유형은 다양하지만 유사한 메서드를 제공하는 것은 하나의 클래스로 만든다.
- 소프트웨어 설계는 분할만 잘해도 품질이 크게 높아진다. 관심사를 분리하면 코드를 이해하고 보수하기 훨씬 더 쉬워진다.

### 리팩토링 플로우

1. 문제 정의
2. 코드 수정
3. **테스트** 돌리기 - 테스트 케이스가 하나라도 실패하면 다음 변경으로 넘어가기 전에 오류를 수정
4. 반복

---
## 15장 - JUnit 들여다보기

*JUnit; Java용 테스트 프레임워크*

- 15장은 전반적으로 코드를 보고, 개선할 부분을 언급한다. 
- 코드 예시는 전체적으로 이해하지 못했으나 어떤 부분을 리팩토링하면 좋을지 알게되었다. (17장과 연결)
- 맨 처음 코드리뷰를 할 때에는 어떤 부분을 개선할 수 있을지 전혀 감이 안왔는데 변수 이름 앞에 범위를 명시할 필요가 없다던지, 변수명에 대한 의문이라던지 이것 저것 많이 알게 되었다.
- 세상에 개선이 불필요한 모듈은 없다.

---

## 16장 - SerialDate 리팩터링

- SerialDate라는 우수한 코드를 낱낱히 분석한다. 코드 분석할 때의 비판은 악의나 자만과는 거리가 멀다. 비판이 있어야만 발전도 가능하다.
- 클린코드 작성으로 다음 사람은 우리보다 코드를 좀 더 쉽게 이해할 것이다. 그래서 우리보다 코드를 좀 더 쉽게 개선할 것이다.
- 여기에서 언급된 내용들도 17장에서 다시 정리해 볼 수 있다.

---
## 13장 - 동시성
> 2022.5.18

- JS는 싱글 스레드 언어이고, 지금까지의 경험으로는 멀티 스레드를 고려하는 경우가 극히 드물어서 이해하는 게 쉽지 않았다.
  
### 1. 여러 스레드를 동시에 돌리는 이유

- 동시성이 무엇인가? 프로그램의 응답을 기다리면서 낭비되는 자원을 줄이는 것이 동시성의 핵심.
- 동시성이 항상 성능을 높이는 것은 아니다. 대기 시간이 아주 길거나, 독립적 계산이 충분히 많은 경우에만 성능이  높아진다.
- 동시성을 구현한다고 요청이 빨리 처리되는 것은 아니지만 **어플리케이션 입장**에서는 효율적으로 코어를 사용해 처리량을 높일 수 있다.
- 단일 스레드 시스템과 다중 스레드 시스템은 설계가 판이하게 다르다.
  
### 2. 여러 스레드를 동시에 돌리는 어려움

- 두 스레드가 하나의 메서드를 실행하는(문제를 일으킬 수 있는) 잠재적인 경로가 수없이 많다.
  
### 3. 이 어려움에 대처하는 클린코드 작성법

- **SRP; 단일 책임 원칙**을 준수한다. 주어진 메서드/클래스/컴포넌트를 변경할 이유가 하나여야 한다.
- 동시성은 복잡하기 때문에 다른 코드와 분리해야한다. 가능한 독립적으로 자신만의 세상에 존재하는 스레드를 구현한다.
- 자료를 캡슐화해서 공유 자료를 최대한 줄인다. Read only로 사용하거나, 사본을 사용해라.
- 생산자-소비자, 읽기-쓰기, 식사하는 철학자들과 같은 문제를 이해하고 이를 해결할 수 있는 **알고리즘을 공부**해라.
- 종료 코드를 개발 초기부터 고민하고, 이미 나온 알고리즘을 검토해라.

### 4. 동시성을 테스트하는 방법과 문제점

- 코드가 올바르다고 증명하기는 현실적으로 불가능하나 충분한 테스트는 위험을 낮춘다.
- 테스트 코드 작성 시, 고려해야할 것이 아주 많고 어렵다... 할 수 있는한 많이 작성해야하는 건가...? 문제가 어디서 발생할지 모르고, 아주 가끔 발생하는 에러들도 고려해야한다는 게 어려운 지점인 것 같다. 진정... 아주 가끔 발생하는 에러도 고려할 필요가 있는가?

---

## 11장 - 시스템
> 2022.5.12


- 시스템은 깨끗해야한다.
- 실제로 돌아가는 가장 단순한 시스템 & 확장성

### 1. 관심사 분리

**Main 분리**

- 시스템은 준비과정과 런타임 로직을 분리해야한다.
- 객체의 생성은 시작단계에서, 비즈니스 로직은 객체를 사용하는데 집중한다.
- 애플리케이션은 모든 객체가 잘 생성되었다고 가정하고, 만들어진 객체를 사용한다.

**팩토리**

- 객체가 생성되는 시점을 애플리케이션이 결정할 수 있지만 애플리케이션이 객체를 생성하는 코드를 모르는 것

**횡단 관심사 분리**

- 이해가 안간다. EJB, AOP, Java proxy, POJO... 모르는 단어가 쏟아진다.

*POJO; Plain Old Java Object. 객체지향적인 원리에 충실한 오래된 자바 오브젝트*

### 2. 의존성 주입(Dependency Injection)

- 객체 생성을 DI 컨테이너에 맡긴다. 
- DI 컨테이너가 setter 메서드나 인수를 사용해 의존성을 설정한다.
- Java를 살짝 배우긴 했지만 의존성 주입이라는 말이 잘 이해 되지 않았었는데 조금 알 것 같다.

### 3. 테스트 주도 시스템 아키텍처 구축

- 처음부터 올바르게 시스템을 만들 수는 없다.
- **TDD, 리팩터링, 클린 코드**로 시스템을 조정하고 확장하기 쉽게 만들어야한다.
- 단순하고, 잘 분리된 아키텍처로 결과물을 재빨리 출시한 후, 구조를 추가하면서 조금씩 확장해나가도 좋다.
- 변하는 환경에 대처해 진로를 변경할 능력도 필요하다.

---

## 12장 - 창발성

*창발성; 작은 요소들의 반복이 전체 구조에 영향을 미치는 것*

### 1. 모든 테스트를 실행한다

- **SRP(Single Responsibility Principle, 단일 책임 원칙)를 준수**하는 클래스가 테스트가 훨씬 더 쉽다.
- 결합도가 높으면 테스트를 작성하기 어럽다. 테스트를 실행하는 규칙을 따르면 낮은 결합도와 높은 응집력이라는 목표를 저절로 달성한다. 자연스럽게 설계 품질이 높아진다.
- 테스트 케이스가 있으니까 리팩터링하면서 시스템이 깨질 걱정을 할 필요가 없다.
  
### 2. 중복을 없앤다

- 중복은 추가작업, 추가 위험, 불필요한 복잡도를 뜻한다.
- Template method 패턴

### 3. 프로그래머의 의도를 표현한다

- 소프트웨어 프로젝트 비용 중 대부분은 유지보수에 들어간다. 개발자가 의도가 분명한 코드를 짤 수록 다른 사람이 그 코드를 이해하기 쉬워지고, 유지보수 비용이 적게 들어간다.

** 의도를 표현하는 방법**

- 좋은 이름을 선택한다.
- 함수와 클래스 크기를 가능한 줄인다.
- 표준 명칭을 사용한다.
- 단위 테스트 케이스를 꼼꼼히 작성한다. 잘 만든 테스트 케이스를 읽어보면 클래스 긴으이 한눈에 들어온다.
- 다른 사람이 읽기 쉽게 만들려 충분히 고민, 노-력한다.

### 4. 클래스와 메서드 수를 최소로 줄인다

- 클래스와 메서드 크기를 줄이자고 조그만 클래스와 메서드를 수없이 만들면 득보다 실이 커진다.
- 테스트 케이스를 만들고 중복을 제거하고 의도를 표현하는 작업이 더 중요하다. 실용적인 방식을 택하자.
  
  